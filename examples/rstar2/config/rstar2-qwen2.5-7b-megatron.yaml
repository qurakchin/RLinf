defaults:
  - override hydra/job_logging: stdout

hydra:
  run:
    dir: .
  output_subdir: null

cluster:
  num_nodes: 1
  component_placement:
    actor,rollout,reward: all
    # rStar2 only support collective placement now. Therefore these settings are ignored.
    # rollout: 0-3
    # inference: 4-5
    # actor: 6-7
    # reward: 0-3

runner:
  task_type: reasoning
  logger:
    log_path: ${runner.output_dir}/${runner.experiment_name}
    project_name: rlinf
    experiment_name: ${runner.experiment_name}
    logger_backends: ["tensorboard"] # wandb, swanlab

  max_epochs: 1000
  max_steps: -1

  val_check_interval: 1
  save_interval: 10

  seq_length: 10240

  enable_dynamic_batch_size: True
  max_tokens_per_mbs: 16384

  resume_dir: auto
  experiment_name: rstar2-7b
  output_dir: ../results

algorithm:
  group_size: 32

  n_minibatches: 1
  training_batch_size_per_gpu: 1 # micro batch size
  rollout_batch_size_per_gpu: null # If set to null, rollout_batch_size will be evenly divided across all inference instances. You can reduce this parameter if inference consumes too much GPU memory.

  # mbs to do log prob inference, can be set to
  # lower than rollout_batch_size_per_gpu to reduce
  # memory usage
  logprob_forward_micro_batch_size: 1 # ${.rollout_batch_size_per_gpu}

  # val rollout mbs
  val_rollout_batch_size_per_gpu: 4 # ${.rollout_batch_size_per_gpu}

  recompute_logprobs: False
  shuffle_rollout: False

  # GRPO loss params
  loss_type: actor
  loss_agg_func: "token-mean"
  kl_beta: 0.0 # 0.001
  kl_penalty_type: low_var_kl
  ratio_clip_eps: 0.2
  entropy_bonus: 0.0
  calculate_entropy: False
  clip_ratio_c: 3.0 # 3.0
  clip_ratio_low: 0.2 # if null or not set, will use ratio_clip_eps
  clip_ratio_high: 0.28 # if null or not set, will use ratio_clip_eps
  clip_log_ratio_min: -20 # if null or not set, will not clip
  clip_log_ratio_max: 20 # if null or not set, will not clip

  adv_type: grpo
  normalize_advantages: False
  early_stop_imp_ratio: 5.0
  use_valid_token_scale: False

  # params for rollout
  sampling_params:
    do_sample: True
    temperature: 1.0
    top_k: -1
    top_p: 1.0
    repetition_penalty: 1.0
    max_new_tokens: ${subtract:${runner.seq_length}, ${data.max_prompt_length}}
    min_new_tokens: 1
  
  down_sampling:
    do_down_sampling: true
    down_sampling_config:
      reject_equal_reward: true
      roc_error_ratio: true
      roc_answer_format: true
      min_zero_reward_trace_num: 2
      min_non_zero_reward_trace_num: 2
      down_sample_to_n: 16
  
inference:
  model_type: ${rollout.model.model_type}
  group_name: "InferenceGroup"
  load_from_actor: True
  model:
    tensor_model_parallel_size: 2
    pipeline_model_parallel_size: 1
    sequence_parallel: True

agentloop:
  group_name: "AgentLoopGroup"
  max_user_turns: null
  max_assistant_turns: 5
  max_parallel_calls: 1
  tool_response_truncate_side: "middle"
  print_outputs: True # whether to print the outputs (token ids, texts, tool calls, etc.) of agent loop worker.
  # demo specific parameters. not used in this demo. you can add your own parameters here.
  continue_at_tool_failure: True
  max_tool_response_length: 256

rollout:
  group_name: "RolloutGroup"

  gpu_memory_utilization: 0.5

  model:
    model_path: /path/to/model/Qwen2.5-7B-Instruct
    model_type: qwen2.5
    precision: ${actor.model.precision}              # precision for rollout model, support [fp16, bf16, fp32]
  enforce_eager: False         # if False, rollout engine will capture cuda graph, which will take more time to initialize.
  distributed_executor_backend: mp   # ray or mp
  disable_log_stats: False
  detokenize: False            # Whether to detokenize the output. During RL we actually don't need to detokenize it. Can be set to True for debugging.
  padding: null               # will be tokenizer.pad_token_id if null. it is used to filter megatron's padding for rollout engine
  eos: null                   # will be tokenizer.eos_token_id if null.

  rollout_backend: sglang     # here choose which backend to rollout,support [sglang, vllm] 

  custom_chat_template: "\n{%- if tools %}\n    {{- '<|im_start|>system\\n' }}\n    {%- if messages[0]['role'] == 'system' %}\n        {{- messages[0]['content'] }}\n    {%- else %}\n        {{- 'A conversation between User and Assistant. The User asks a question, and the Assistant solves it. The Assistant first thinks about the reasoning process in the mind and then provides the User with the answer. The reasoning process is enclosed within <reason> </reason> and answer is enclosed within <answer> </answer> tags, respectively, i.e., <reason> reasoning process here </reason> <answer> answer here </answer>.' }}\n    {%- endif %}\n    {{- \"\\n\\n# Tools\\n\\nYou may call one or more functions to assist with the user query.\\n\\nYou are provided with function signatures within <tools></tools> XML tags:\\n<tools>\" }}\n    {%- for tool in tools %}\n        {{- \"\\n\" }}\n        {{- tool | tojson }}\n    {%- endfor %}\n    {{- \"\\n</tools>\\n\\nFor each function call, return a json object with function name and arguments within <tool_call></tool_call> XML tags:\\n<tool_call>\\n{\\\"name\\\": <function-name>, \\\"arguments\\\": <args-json-object>}\\n</tool_call><|im_end|>\\n\" }}\n{%- else %}\n    {%- if messages[0]['role'] == 'system' %}\n        {{- '<|im_start|>system\\n' + messages[0]['content'] + '<|im_end|>\\n' }}\n    {%- else %}\n        {{- '<|im_start|>system\\nA conversation between User and Assistant. The User asks a question, and the Assistant solves it. The Assistant first thinks about the reasoning process in the mind and then provides the User with the answer. The reasoning process is enclosed within <reason> </reason> and answer is enclosed within <answer> </answer> tags, respectively, i.e., <reason> reasoning process here </reason> <answer> answer here </answer>.<|im_end|>\\n' }}\n    {%- endif %}\n{%- endif %}\n{%- for message in messages %}\n    {%- if (message.role == \"user\") or (message.role == \"system\" and not loop.first) or (message.role == \"assistant\" and not message.tool_calls) %}\n        {{- '<|im_start|>' + message.role + '\\n' + 'You must put your answer inside <answer> </answer> tags, i.e., <answer> answer here </answer>. And your final answer will be extracted automatically by the \\\\boxed{} tag.\\nThis is the problem:\\n' + message.content + '<|im_end|>' + '\\n' }}\n    {%- elif message.role == \"assistant\" %}\n        {{- '<|im_start|>' + message.role }}\n        {%- if message.content %}\n            {{- '\\n' + message.content }}\n        {%- endif %}\n        {%- for tool_call in message.tool_calls %}\n            {%- if tool_call.function is defined %}\n                {%- set tool_call = tool_call.function %}\n            {%- endif %}\n            {{- '\\n<tool_call>\\n{\"name\": \"' }}\n            {{- tool_call.name }}\n            {{- '\", \"arguments\": ' }}\n            {{- tool_call.arguments | tojson }}\n            {{- '}\\n</tool_call>' }}\n        {%- endfor %}\n        {{- '<|im_end|>\\n' }}\n    {%- elif message.role == \"tool\" %}\n        {%- if (loop.index0 == 0) or (messages[loop.index0 - 1].role != \"tool\") %}\n            {{- '<|im_start|>user' }}\n        {%- endif %}\n        {{- '\\n<tool_response>\\n' }}\n        {{- message.content }}\n        {{- '\\n</tool_response>' }}\n        {%- if loop.last or (messages[loop.index0 + 1].role != \"tool\") %}\n            {{- '<|im_end|>\\n' }}\n        {%- endif %}\n    {%- endif %}\n{%- endfor %}\n{%- if add_generation_prompt %}\n    {{- '<|im_start|>assistant\\n<reason>' }}\n{%- endif %}\n"

  sglang:
    attention_backend: triton # [flashinfer, triton] for more, see sglang's doc
    decode_log_interval: 500000 # the interval for SGLang to log the decode time and other stats.
    use_torch_compile: False # enable torch_compile in SGLang for rollout.
    torch_compile_max_bs: 128 # the maximum batch size for torch compile. If the batch size is larger than this, torch compile will not be used.

  vllm:
    attention_backend: FLASH_ATTN #[FLASH_ATTN,XFORMERS] for more, see vllm's doc
    enable_chunked_prefill: True  # enable vllm to use chunked_prefill.
    enable_prefix_caching: True   # enable vllm to use prefix_caching.
    enable_flash_infer_sampler: True # if True, vllm will use flashinfer to do sampling.
    max_num_batched_tokens: null # the maximum number of tokens to be batched together in vllm. If set to null, vllm will use its default value.
    torch_profiler_dir: null # if not null, vllm will enable torch profiler and save the result to the specified directory.

  return_logprobs: ${not:${algorithm.recompute_logprobs}}

  tensor_parallel_size: 2
  pipeline_parallel_size: 1
  
  validate_weight: False # whether to send all weights at first for weight comparison.
  validate_save_dir: null # the directory to save the weights for comparison. If validate_weight is True, this will be used to save the weights for comparison.
  print_outputs: False         # whether to print the outputs (token ids, texts, etc.) of rollout engine.

  max_running_requests: 1024 # the maximum number of running requests in the rollout engine.
  cuda_graph_max_bs: 160 # the maximum batch size for cuda graph. If the batch size is larger than this, cuda graph will not be used.

data:
  type: rstar2
  max_prompt_length: 2048
  filter_prompt_by_length: True
  rollout_batch_size: 128
  val_rollout_batch_size: null
  num_workers: 2
  prompt_key: prompt
  answer_key: solutions
  apply_chat_template: True
  shuffle: True
  validation_shuffle: True
  seed: 1234
  train_data_paths: ["/path/to/train.jsonl"]
  val_data_paths: ["/path/to/train.jsonl"]
  apply_chat_template_kwargs: {}

# Tools configuration for AgentLoop
tools:
  mcp_file_system: null
  codejudge:
    host_addr: 127.0.0.1
    host_port: 8000
    concurrency_limit: 128

actor:
  group_name: "ActorGroup"
  training_backend: megatron
  mcore_gpt: True
  spec_name: decoder_gpt

  offload_optimizer: True
  offload_weight: True
  offload_grad: True
  enable_dp_load_balance: True

  calculate_flops: False

  seed: 1234

  model:
    megatron_checkpoint: null
    precision: bf16
    add_bias_linear: False

    tensor_model_parallel_size: 2
    pipeline_model_parallel_size: 1

    activation: swiglu
    sequence_parallel: True
    # recompute_method: block
    # recompute_granularity: selective

    recompute_method: block
    recompute_granularity: full
    recompute_num_layers: 20

    seq_length: ${runner.seq_length}
    encoder_seq_length: ${runner.seq_length}

    normalization: rmsnorm

    position_embedding_type: rope

    apply_rope_fusion: True
    bias_dropout_fusion: False
    persist_layer_norm: False
    bias_activation_fusion: False
    attention_softmax_in_fp32: True
    batch_p2p_comm: False
    variable_seq_lengths: True
    gradient_accumulation_fusion: False
    moe_token_dispatcher_type: alltoall
    use_cpu_initialization: False

  optim:
    optimizer: adam
    bf16: True
    fp16: False
    lr: 1e-6
    adam_beta1: 0.9
    adam_beta2: 0.999
    adam_eps: 1.0e-08
    min_lr: 0.0
    weight_decay: 0.01
    clip_grad: 1.0

    # megatron config
    use_distributed_optimizer: True
    overlap_grad_reduce: False
    overlap_param_gather: False
    optimizer_enable_pin: False
    overlap_param_gather_with_optimizer_step: False
    initial_loss_scale: 65536

  lr_sched:
    lr_warmup_fraction: 0.1
    lr_warmup_init: 0.0
    # lr_warmup_iters: 0
    max_lr: 1e-6
    min_lr: 0.0
    lr_decay_style: constant
    lr_decay_iters: 200

  tokenizer:
    tokenizer_model: ${rollout.model.model_path}
    use_fast: False
    trust_remote_code: True
    padding_side: 'right'

  megatron:
    ddp_bucket_size: null
    distributed_backend: nccl # Support 'nccl' and 'gloo'
    distributed_timeout_minutes: 60
    ckpt_format: torch
    use_dist_ckpt: False
    tp_comm_bootstrap_backend: nccl
    tp_comm_overlap_cfg: null # tp_comm_overlap_cfg.yaml
    use_hf_ckpt: True # if true, will transfer hf model to generate megatron checkpoint and use it for training.
    use_profiler: False # if true, will enable torch profiler when training, pay attention it has influence on performance

    ckpt_convertor: # config for ckpt convertor
      model: Qwen2.5-7B
      hf_model_path: ${rollout.model.model_path} # path to the hf model
      save_path: ${runner.output_dir}/${runner.experiment_name}/converted_ckpts/actor
      use_gpu_num : 0
      use_gpu_index: null
      process_num: 16 # number of processes to use for checkpointing
      tensor_model_parallel_size: ${actor.model.tensor_model_parallel_size}
      pipeline_model_parallel_size: ${actor.model.pipeline_model_parallel_size}

    profiler: # profile megatron when inference and traning
      output_dir: ${runner.output_dir}/${runner.experiment_name}/profiler
      activities: ["cpu", "cuda"]
      record_shapes: False
      profile_memory: False
      with_stack: False
      with_flops: False
      with_modules: True
      export_tensorboard: True
      export_chrome_trace: False
      chrome_filename_prefix: "chrome_trace"
      schedule_warmup: 2
      schedule_active: 1
      schedule_repeat: 1 # inference and training will repeat such times
      # schedule_wait: it will be set at runtime

reward:
  group_name: "RewardGroup"
  use_reward_model: False
  reward_type: 'rstar2'
  reward_scale: 1.0

  tokenizer:
    tokenizer_model: ${actor.tokenizer.tokenizer_model}
    use_fast: ${actor.tokenizer.use_fast}
    trust_remote_code: ${actor.tokenizer.trust_remote_code}
    padding_side: ${actor.tokenizer.padding_side}

critic:
  use_critic_model: False
